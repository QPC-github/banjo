# Disassembler library

This is the library that loads Dex files and disassembles to smali. For an example of how to use it in code, see
the [standalone disassembler](../disas_to_files.py).

## Dex parser

[dex.py](../android/dex.py)

The main part is the `DexFile` class. Initialize it with bytes of a Dex file and it will parse strings, types, code
blocks, and everything else.

There are also parsers for LEB128 and MUTF-8 with basic tests.

## Smali diasssembler

[smali.py](../android/smali.py)

The main part is the `disassemble` function. It takes in a `DexFile` object and disassembles bytes at an address,
returning tokenized disassembly of a single instruction. For more detailed analysis, you might to use other functions
which expose the bytecode constructs at a lower level.

## generating instruction info

[generate_instruction_info.py](../android/generate_instruction_info.py)
and [instruction_data.pickle](../android/instruction_data.pickle)

The disassembler uses cached instruction data including opcodes, syntax, and mnemonics. This was autogenerated from the
Android documentation and saved in a pickle. If new instructions are added in a later version of Dex, it might be
possible to regenerate the instruction data to get text disassembly working without making any changes to the code (this
depends on the changes not being too weird, which is unlikely).

## compat

[compat/](../android/compat/__init__.py)

Because the disassembler library is designed to work both inside Binary Ninja and as a standalone, it needs a
compatibility layer for things like printing/logging and enums defined by Binary Ninja (e.g. Endianness).
